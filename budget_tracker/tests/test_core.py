()






# Импортируем все необходимые библиотеки:
# os - для работы с операционной системой (чтобы работать с файлами и проверять существование тестовой базы данных)
# sqlite3 - для работы с базой данных
# unittest - используется для написания тестов
import os
import sqlite3
import unittest

# Импортируем класс DataBase, который будет тестироваться 
from core.database import DataBase

# Определяем класс Тестов. 
# Он наследуется от unittest.TestCase, что позволяет использовать методы assertEqual, setUp и т.д.
class DataBaseTest(unittest.TestCase):

    # Передаем имя файла тестовой базы данных, каждый тест будет работать с этим файлом
    TEST_DB = "test_db.sqlite"

    # Метод, который выполняется перед каждым тестом автоматически. 
    def setUp(self):

         # Проверяем остался ли файл базы данных от предыдущего теста, 
        if os.path.exists(self.TEST_DB):

            # Если да, то удаляем его (чтобы начинать каждый тест «с нуля»)
            os.remove(self.TEST_DB)
        
        # Создаем оъект базы данных, указываем путь до тестового файла
        self.db = DataBase(self.TEST_DB)
        # Создаем таблицу в базе данных, через метод импортированного ранее класса DataBase
        self.db.create_db()

    # Объявляем тест, который проверяет добавление информации в базу данных
    def test_add_in_db(self):

        # Добавляем транзакцию через метод импортированного ранее класса DataBase, который мы и тестируем
        self.db.add_transaction(10000.06, "food", "15.11.2025", "доход")

        # Вручную открываем подключение к базе данных, чтобы проверить содержимое (и сразу закрываем подключение)
        with sqlite3.connect(self.TEST_DB) as db:
            # Создаем курсор - объект, который позволяет выполнять команды SQL
            cursor = db.cursor()
            # Получаем все строки из таблицы базы данных
            cursor.execute("SELECT * FROM transactions")
            # Записываем данные в переменную
            result = cursor.fetchall()

        # Формируем ожидаемый результат (то, как должна выглядеть таблица)
        expected = [(1, 10000.06, "food", "15.11.2025", "доход")]
        # Сравниваем результат с ожиданием
        self.assertEqual(result, expected)

    # Объявляем тест, который проверяет коректное получение информации из базы данных
    def test_get_db(self):
        # Добавляем транзакции через метод импортированного ранее класса DataBase
        self.db.add_transaction(100, "transport", "2024-05-05", "расход")
        self.db.add_transaction(500, "salary", "2024-05-10", "доход")
        # Получа все транзакции через метод импортированного ранее класса DataBase, который мы и тестируем
        rows = self.db.get_all_transactions()
        # Проверяем, что записей в таблице ровно 2
        self.assertEqual(len(rows), 2)
        # Проверяем, что в 1 строке(0 индекс) и 3 столбце(2 индекс, столбец считается 3, 
        # т.к поле ID стоящее на 0 индексе подразумевается, но не прописывается) 
        # соответствует категории - "transport"
        self.assertEqual(rows[0][2],"transport")
        # Проверяем, что во 2 строке(1 индекс) и 4 столбце(3 индекс, столбец считается 4, 
        # т.к поле ID стоящее на 0 индексе подразумевается, но не прописывается) 
        # соответствует дате - "2024-05-10"
        self.assertEqual(rows[1][3],"2024-05-10")


